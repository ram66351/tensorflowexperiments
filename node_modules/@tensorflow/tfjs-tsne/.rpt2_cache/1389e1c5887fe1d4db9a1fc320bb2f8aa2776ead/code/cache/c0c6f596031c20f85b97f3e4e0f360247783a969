{"code":"import * as tf from '@tensorflow/tfjs-core';\r\nimport * as gl_util from './gl_util';\r\nexport function generateDistanceComputationSource(format) {\r\n    var source = \"\\n    #define DATA_NUM_PACKED_DIMENSIONS \" + format.pixelsPerPoint + \".\\n    #define DATA_POINTS_PER_ROW \" + format.pointsPerRow + \".\\n    #define DATA_NUM_ROWS \" + format.numRows + \".\\n    #define TEXTURE_WIDTH \" + format.pointsPerRow * format.pixelsPerPoint + \".\\n\\n    //returns the texture coordinate for point/dimension\\n    vec2 dataTexCoordinates(int id, int dimension) {\\n      float id_f = float(id);\\n      float row = (floor(id_f/DATA_POINTS_PER_ROW)+0.5) / DATA_NUM_ROWS;\\n      float col = ((mod(id_f,DATA_POINTS_PER_ROW)*(DATA_NUM_PACKED_DIMENSIONS)\\n                  + float(dimension)) + 0.5) / (TEXTURE_WIDTH);\\n      return vec2(col,row);\\n    }\\n\\n    //compute the euclidean squared distances between two points i and j\\n    float pointDistanceSquared(int i, int j) {\\n      vec4 result = vec4(0,0,0,0);\\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\\n      for(int d = 0; d < num_iter; ++d) {\\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\\n        vec4 vj = texture(data_tex,dataTexCoordinates(j,d));\\n        result += (vi-vj)*(vi-vj);\\n      }\\n      return (result.r+result.g+result.b+result.a);\\n    }\\n\\n    //compute the euclidean squared distances between two points i and j\\n    vec4 pointDistanceSquaredBatch(int i, int j0, int j1, int j2, int j3) {\\n      vec4 result = vec4(0,0,0,0);\\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\\n      for(int d = 0; d < num_iter; ++d) {\\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\\n        vec4 vj0 = texture(data_tex,dataTexCoordinates(j0,d));\\n        vec4 vj1 = texture(data_tex,dataTexCoordinates(j1,d));\\n        vec4 vj2 = texture(data_tex,dataTexCoordinates(j2,d));\\n        vec4 vj3 = texture(data_tex,dataTexCoordinates(j3,d));\\n        vj0 = (vi-vj0); vj0 *= vj0;\\n        vj1 = (vi-vj1); vj1 *= vj1;\\n        vj2 = (vi-vj2); vj2 *= vj2;\\n        vj3 = (vi-vj3); vj3 *= vj3;\\n        result.r += (vj0.r+vj0.g+vj0.b+vj0.a);\\n        result.g += (vj1.r+vj1.g+vj1.b+vj1.a);\\n        result.b += (vj2.r+vj2.g+vj2.b+vj2.a);\\n        result.a += (vj3.r+vj3.g+vj3.b+vj3.a);\\n      }\\n      return result;\\n    }\\n    \";\r\n    return source;\r\n}\r\nexport function generateMNISTDistanceComputationSource() {\r\n    var source = \"\\n  #define POINTS_PER_ROW 250.\\n  #define NUM_ROWS 240.\\n  #define TEXTURE_WIDTH 3500.\\n  #define TEXTURE_HEIGHT 3360.\\n  #define DIGIT_WIDTH 14.\\n  #define NUM_PACKED_DIMENSIONS 196\\n\\n  //returns the texture coordinate for point/dimension\\n  vec2 dataTexCoordinates(int id, int dimension) {\\n    float id_f = float(id);\\n    float dimension_f = float(dimension);\\n    float col = ((mod(id_f,POINTS_PER_ROW)*DIGIT_WIDTH));\\n    float row = (floor(id_f/POINTS_PER_ROW)*DIGIT_WIDTH);\\n\\n    return (vec2(col,row)+\\n            vec2(mod(dimension_f,DIGIT_WIDTH),floor(dimension_f/DIGIT_WIDTH))+\\n            vec2(0.5,0.5)\\n            )/\\n            vec2(TEXTURE_WIDTH,TEXTURE_HEIGHT);\\n  }\\n\\n  //compute the euclidean squared distances between two points i and j\\n  float pointDistanceSquared(int i, int j) {\\n    vec4 result = vec4(0,0,0,0);\\n    for(int d = 0; d < NUM_PACKED_DIMENSIONS; d+=1) {\\n      vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\\n      vec4 vj = texture(data_tex,dataTexCoordinates(j,d));\\n      result += (vi-vj)*(vi-vj);\\n    }\\n    return (result.r+result.g+result.b+result.a);\\n  }\\n\\n  //compute the euclidean squared distances between two points i and j\\n  vec4 pointDistanceSquaredBatch(int i, int j0, int j1, int j2, int j3) {\\n    vec4 result = vec4(0,0,0,0);\\n    for(int d = 0; d < NUM_PACKED_DIMENSIONS; d+=1) {\\n      vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\\n      vec4 vj0 = texture(data_tex,dataTexCoordinates(j0,d));\\n      vec4 vj1 = texture(data_tex,dataTexCoordinates(j1,d));\\n      vec4 vj2 = texture(data_tex,dataTexCoordinates(j2,d));\\n      vec4 vj3 = texture(data_tex,dataTexCoordinates(j3,d));\\n      vj0 = (vi-vj0); vj0 *= vj0;\\n      vj1 = (vi-vj1); vj1 *= vj1;\\n      vj2 = (vi-vj2); vj2 *= vj2;\\n      vj3 = (vi-vj3); vj3 *= vj3;\\n      result.r += (vj0.r+vj0.g+vj0.b+vj0.a);\\n      result.g += (vj1.r+vj1.g+vj1.b+vj1.a);\\n      result.b += (vj2.r+vj2.g+vj2.b+vj2.a);\\n      result.a += (vj3.r+vj3.g+vj3.b+vj3.a);\\n    }\\n    return result;\\n  }\\n  \";\r\n    return source;\r\n}\r\nexport function generateKNNClusterTexture(numPoints, numClusters, numNeighbors) {\r\n    var pointsPerRow = Math.floor(Math.sqrt(numPoints * numNeighbors) / numNeighbors);\r\n    var numRows = Math.ceil(numPoints / pointsPerRow);\r\n    var dataShape = { numPoints: numPoints, pixelsPerPoint: numNeighbors, numRows: numRows, pointsPerRow: pointsPerRow };\r\n    var pointsPerCluster = Math.ceil(numPoints / numClusters);\r\n    var textureValues = new Float32Array(pointsPerRow * numNeighbors * numRows * 2);\r\n    for (var i = 0; i < numPoints; ++i) {\r\n        var clusterId = Math.floor(i / pointsPerCluster);\r\n        for (var n = 0; n < numNeighbors; ++n) {\r\n            var id = (i * numNeighbors + n) * 2;\r\n            textureValues[id] = Math.floor(Math.random() * pointsPerCluster) +\r\n                clusterId * pointsPerCluster;\r\n            textureValues[id + 1] = Math.random();\r\n        }\r\n    }\r\n    var backend = tf.ENV.findBackend('webgl');\r\n    if (backend === null) {\r\n        throw Error('WebGL backend is not available');\r\n    }\r\n    var gpgpu = backend.getGPGPUContext();\r\n    var knnGraph = gl_util.createAndConfigureTexture(gpgpu.gl, pointsPerRow * numNeighbors, numRows, 2, textureValues);\r\n    return { knnGraph: knnGraph, dataShape: dataShape };\r\n}\r\nexport function generateKNNLineTexture(numPoints, numNeighbors) {\r\n    var pointsPerRow = Math.floor(Math.sqrt(numPoints * numNeighbors) / numNeighbors);\r\n    var numRows = Math.ceil(numPoints / pointsPerRow);\r\n    var dataShape = { numPoints: numPoints, pixelsPerPoint: numNeighbors, numRows: numRows, pointsPerRow: pointsPerRow };\r\n    var textureValues = new Float32Array(pointsPerRow * numNeighbors * numRows * 2);\r\n    for (var i = 0; i < numPoints; ++i) {\r\n        for (var n = 0; n < numNeighbors; ++n) {\r\n            var id = (i * numNeighbors + n) * 2;\r\n            textureValues[id] =\r\n                Math.floor(i + n - (numNeighbors / 2) + numPoints) % numPoints;\r\n            textureValues[id + 1] = 1;\r\n        }\r\n    }\r\n    var backend = tf.ENV.findBackend('webgl');\r\n    if (backend === null) {\r\n        throw Error('WebGL backend is not available');\r\n    }\r\n    var gpgpu = backend.getGPGPUContext();\r\n    var knnGraph = gl_util.createAndConfigureTexture(gpgpu.gl, pointsPerRow * numNeighbors, numRows, 2, textureValues);\r\n    return { knnGraph: knnGraph, dataShape: dataShape };\r\n}\r\nexport function generateKNNClusterData(numPoints, numClusters, numNeighbors) {\r\n    var pointsPerCluster = Math.ceil(numPoints / numClusters);\r\n    var distances = new Float32Array(numPoints * numNeighbors);\r\n    var indices = new Uint32Array(numPoints * numNeighbors);\r\n    for (var i = 0; i < numPoints; ++i) {\r\n        var clusterId = Math.floor(i / pointsPerCluster);\r\n        for (var n = 0; n < numNeighbors; ++n) {\r\n            var id = (i * numNeighbors + n);\r\n            distances[id] = Math.random();\r\n            indices[id] = Math.floor(Math.random() * pointsPerCluster) +\r\n                clusterId * pointsPerCluster;\r\n        }\r\n    }\r\n    return { distances: distances, indices: indices };\r\n}\r\nexport function generateKNNLineData(numPoints, numNeighbors) {\r\n    var distances = new Float32Array(numPoints * numNeighbors);\r\n    var indices = new Uint32Array(numPoints * numNeighbors);\r\n    for (var i = 0; i < numPoints; ++i) {\r\n        for (var n = 0; n < numNeighbors; ++n) {\r\n            var id = (i * numNeighbors + n);\r\n            distances[id] = 1;\r\n            indices[id] =\r\n                Math.floor(i + n - (numNeighbors / 2) + numPoints) % numPoints;\r\n        }\r\n    }\r\n    return { distances: distances, indices: indices };\r\n}\r\n//# sourceMappingURL=dataset_util.js.map","map":"{\"version\":3,\"file\":\"dataset_util.js\",\"sourceRoot\":\"\",\"sources\":[\"src/dataset_util.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/tsne/tfjs-tsne/dataset_util.d.ts","text":"import { RearrangedData } from './interfaces';\r\nexport declare function generateDistanceComputationSource(format: RearrangedData): string;\r\nexport declare function generateMNISTDistanceComputationSource(): string;\r\nexport declare function generateKNNClusterTexture(numPoints: number, numClusters: number, numNeighbors: number): {\r\n    knnGraph: WebGLTexture;\r\n    dataShape: RearrangedData;\r\n};\r\nexport declare function generateKNNLineTexture(numPoints: number, numNeighbors: number): {\r\n    knnGraph: WebGLTexture;\r\n    dataShape: RearrangedData;\r\n};\r\nexport declare function generateKNNClusterData(numPoints: number, numClusters: number, numNeighbors: number): {\r\n    distances: Float32Array;\r\n    indices: Uint32Array;\r\n};\r\nexport declare function generateKNNLineData(numPoints: number, numNeighbors: number): {\r\n    distances: Float32Array;\r\n    indices: Uint32Array;\r\n};\r\n"}}
