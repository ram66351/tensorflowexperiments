{"code":"import * as tf from '@tensorflow/tfjs-core';\r\nimport * as gl_util from './gl_util';\r\nexport function createEmbeddingSplatterProgram(gpgpu) {\r\n    var vertexShaderSource = \"#version 300 es\\n    precision highp float;\\n    in float vertex_id;\\n\\n    uniform sampler2D embedding_tex;\\n    uniform vec2 minV;\\n    uniform vec2 maxV;\\n    uniform float kernel_support;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n\\n    out vec2 kernel_coords;\\n\\n    void main() {\\n      //TODO Clean up and check performance loss due to the conversions\\n      uint pnt_id = uint((vertex_id / 4.0) + 0.1);\\n      uint quad_id = uint(mod(vertex_id + 0.1,4.));\\n\\n      uint row    = uint((float(pnt_id) + 0.1)/points_per_row);\\n      uint column = uint(float(pnt_id) - float(row) * points_per_row);\\n\\n      float width = (points_per_row * 2.0);\\n      float row_tex = (float(row) + 0.5) / num_rows;\\n      vec2 tex_coords_x = vec2((float(column) * 2. + 0.5) / width, row_tex);\\n      vec2 tex_coords_y = vec2((float(column) * 2. + 1.5) / width, row_tex);\\n\\n      float x_pnt = texture(embedding_tex,tex_coords_x).r;\\n      float y_pnt = texture(embedding_tex,tex_coords_y).r;\\n      vec2 vertex_coords = vec2(x_pnt,y_pnt);\\n\\n      if(quad_id == uint(0)) {kernel_coords = vec2(-1,-1);}\\n      else if(quad_id == uint(1)) {kernel_coords = vec2(1,-1);}\\n      else if(quad_id == uint(2)) {kernel_coords = vec2(1,1);}\\n      else if(quad_id == uint(3)) {kernel_coords = vec2(-1,1);}\\n\\n      vertex_coords += kernel_coords * kernel_support;      // embedding space\\n      vertex_coords = (vertex_coords - minV) / (maxV-minV); //  0:1 space\\n      vertex_coords = vertex_coords * 2.0 - 1.0;            // -1:1 space\\n\\n      gl_Position = vec4(vertex_coords,0,1);\\n    }\\n  \";\r\n    var fragmentShaderSource = \"#version 300 es\\n    precision highp float;\\n    uniform sampler2D kernel_tex;\\n    in vec2 kernel_coords;\\n    out vec4 fragmentColor;\\n\\n    void main() {\\n      fragmentColor = texture(kernel_tex,(kernel_coords + 1.) / 2.0);\\n    }\\n  \";\r\n    return gl_util.createVertexProgram(gpgpu.gl, vertexShaderSource, fragmentShaderSource);\r\n}\r\nexport function executeEmbeddingSplatterProgram(gpgpu, program, targetTex, embeddingTex, kernelTex, targetTexDiameter, numPoints, minX, minY, maxX, maxY, kernelSupport, pntsPerRow, numRows, vertexIdBuffer) {\r\n    var gl = gpgpu.gl;\r\n    var oldProgram = gpgpu.program;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, targetTexDiameter, targetTexDiameter);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    gl.clearColor(0., 0., 0., 0.);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE);\r\n    tf.webgl.webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexIdBuffer); });\r\n    tf.webgl.webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'vertex_id', vertexIdBuffer, 1, 0, 0);\r\n    var embeddingLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'embedding_tex');\r\n    gpgpu.setInputMatrixTexture(embeddingTex, embeddingLocation, 0);\r\n    var kernelLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'kernel_tex');\r\n    gpgpu.setInputMatrixTexture(kernelTex, kernelLocation, 1);\r\n    var kernelSupportLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'kernel_support');\r\n    gl.uniform1f(kernelSupportLoc, kernelSupport);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var minLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'minV');\r\n    gl.uniform2f(minLoc, minX, minY);\r\n    var maxLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'maxV');\r\n    gl.uniform2f(maxLoc, maxX, maxY);\r\n    tf.webgl.webgl_util.callAndCheck(gl, function () { return gl.drawArrays(gl.TRIANGLES, 0, numPoints * 2 * 3); });\r\n    gl.disable(gl.BLEND);\r\n    if (oldProgram != null) {\r\n        gpgpu.setProgram(oldProgram);\r\n        tf.webgl.gpgpu_util.bindVertexProgramAttributeStreams(gpgpu.gl, oldProgram, gpgpu.vertexBuffer);\r\n    }\r\n}\r\nexport function createQInterpolatorProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n    uniform sampler2D embedding_tex;\\n    uniform sampler2D splat_tex;\\n    uniform vec2 minV;\\n    uniform vec2 maxV;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n\\n    void main() {\\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\\n\\n      if(pnt_location.y * points_per_row + pnt_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,0);\\n        return;\\n      }\\n\\n      float emb_width = (points_per_row * 2.0);\\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\\n      vec2 emb_coords_x\\n              = vec2((pnt_location.x * 2.+0.5) / emb_width, emb_row_coord);\\n      vec2 emb_coords_y\\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\\n\\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\\n\\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\\n\\n      float q = (texture2D(splat_tex,splat_coords).r - 1.);\\n\\n      gl_FragColor = vec4(q, 0, 0, 1);\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeQInterpolatorProgram(gpgpu, program, splatTex, embeddingTex, numPoints, minX, minY, maxX, maxY, pntsPerRow, numRows, targetTex) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var embeddingLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'embedding_tex');\r\n    gpgpu.setInputMatrixTexture(embeddingTex, embeddingLocation, 0);\r\n    var splatLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'splat_tex');\r\n    gpgpu.setInputMatrixTexture(splatTex, splatLocation, 1);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var minLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'minV');\r\n    gl.uniform2f(minLoc, minX, minY);\r\n    var maxLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'maxV');\r\n    gl.uniform2f(maxLoc, maxX, maxY);\r\n    gpgpu.executeProgram();\r\n}\r\nexport function createXYInterpolatorProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n    uniform sampler2D embedding_tex;\\n    uniform sampler2D splat_tex;\\n    uniform vec2 minV;\\n    uniform vec2 maxV;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n    uniform float eta;\\n\\n    void main() {\\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\\n      pnt_location.x = floor(pnt_location.x/2.+0.1);\\n\\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,0);\\n        return;\\n      }\\n\\n      float emb_width = (points_per_row * 2.0);\\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\\n      vec2 emb_coords_x\\n              = vec2((pnt_location.x * 2. + 0.5) / emb_width, emb_row_coord);\\n      vec2 emb_coords_y\\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\\n\\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\\n\\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\\n\\n      float q = 0.;\\n      if(mod(gl_FragCoord.x - 0.5,2.) < 0.5 ) {\\n        q = texture2D(splat_tex,splat_coords).g * eta * 2.;\\n      }else{\\n        q = texture2D(splat_tex,splat_coords).b * eta * 2.;\\n      }\\n\\n      gl_FragColor = vec4(q,0.0,0.0,1);\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeXYInterpolatorProgram(gpgpu, program, splatTex, embeddingTex, targetTex, numPoints, minX, minY, maxX, maxY, pntsPerRow, numRows, eta) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow * 2);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var embeddingLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'embedding_tex');\r\n    gpgpu.setInputMatrixTexture(embeddingTex, embeddingLocation, 0);\r\n    var splatLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'splat_tex');\r\n    gpgpu.setInputMatrixTexture(splatTex, splatLocation, 1);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var etaLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'eta');\r\n    gl.uniform1f(etaLoc, eta);\r\n    var minLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'minV');\r\n    gl.uniform2f(minLoc, minX, minY);\r\n    var maxLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'maxV');\r\n    gl.uniform2f(maxLoc, maxX, maxY);\r\n    gpgpu.executeProgram();\r\n}\r\nexport function createAttractiveForcesComputationProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n\\n    uniform sampler2D embedding_tex;\\n    uniform sampler2D offset_tex;\\n    uniform sampler2D neigh_id_tex;\\n    uniform sampler2D neigh_prob_tex;\\n\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n    uniform float num_neighs_per_row;\\n    uniform float eta;\\n\\n    void main() {\\n      //add for nearest pixel interpolation\\n      vec2 half_pxl = vec2(0.5,0.5);\\n\\n      // Dimension of the fragment\\n      // 0 -> x :1 -> y\\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\\n\\n      //Point location in the [points_per_row,num_rows] space\\n      vec2 i_location = gl_FragCoord.xy - half_pxl;\\n      i_location.x = floor(i_location.x / 2. + 0.1);\\n\\n      //just an extra fragment -> return\\n      if(i_location.y*points_per_row + i_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,0);\\n        return;\\n      }\\n\\n      //Offset coordinates for the point\\n      vec2 offset_coord = (i_location + half_pxl) /\\n                                              vec2(points_per_row,num_rows);\\n      //Offset information ...\\n      vec4 offset_info  = texture2D(offset_tex,offset_coord);\\n      //... contains the number of neighbors for the point ...\\n      float num_neighs  = offset_info.z;\\n      //... and the coordinates of the firts neigh in the neigh textures\\n      vec2 offset_neigh = offset_info.xy;\\n\\n      //Computing the coordinates of the point in the texture\\n      //_i represent the point to move, _j the neighbors\\n      float emb_width = (points_per_row * 2.0);\\n      float emb_row_i = (i_location.y + 0.5) / num_rows;\\n      vec2 x_i_coord = vec2((i_location.x * 2. + 0.5) / emb_width, emb_row_i);\\n      vec2 y_i_coord = vec2((i_location.x * 2. + 1.5) / emb_width, emb_row_i);\\n      //getting the coordinates in the embedding\\n      float x_i = texture2D(embedding_tex,x_i_coord).r;\\n      float y_i = texture2D(embedding_tex,y_i_coord).r;\\n\\n      //Sum of all attractive forces\\n      float sum_pos = 0.;\\n\\n      //Can't be higher than 1000 (perplexity is usually around 30)\\n      //and a 'while' can't be used\\n      for(int n = 0; n < 2000; ++n) {\\n        //Actual check on number of neighbors\\n        if(float(n) >= num_neighs) {\\n          break;\\n        }\\n\\n        //Get the id and the probability for the neighbor\\n        float pij = texture2D(neigh_prob_tex,\\n                              (offset_neigh + half_pxl) / num_neighs_per_row\\n                             ).r;\\n        float neigh_id = texture2D(neigh_id_tex,\\n                                  (offset_neigh + half_pxl) / num_neighs_per_row\\n                                  ).r;\\n\\n        //Getting the coordinates of the neighbor\\n        vec2 j_location = vec2(mod(neigh_id + 0.1, points_per_row),\\n                               floor(neigh_id / points_per_row + 0.1));\\n        float emb_row_j = (j_location.y + 0.5) / num_rows;\\n        vec2 x_j_coord = vec2((j_location.x * 2. + 0.5) / emb_width, emb_row_j);\\n        vec2 y_j_coord = vec2((j_location.x * 2. + 1.5) / emb_width, emb_row_j);\\n        float x_j = texture2D(embedding_tex,x_j_coord).r;\\n        float y_j = texture2D(embedding_tex,y_j_coord).r;\\n\\n        //Actual computation of the attractive forces\\n        float dist_x    = (x_i - x_j);\\n        float dist_y    = (y_i - y_j);\\n        float qij       = 1. / (1. + dist_x * dist_x + dist_y * dist_y);\\n        //the update depends on the dimension that this fragment represents\\n        if(dimension < 0.5) {\\n          // * 4 / (num_points*2) -> * 2 / num_points\\n          sum_pos += eta * 2. * pij * qij * dist_x / (num_points);\\n        }else{\\n          sum_pos += eta * 2. * pij * qij * dist_y / (num_points);\\n        }\\n\\n        //Increase the coordinate of the neigh in the neigh_id texture\\n        offset_neigh.x += 1.;\\n        //check if the new neigh is in the next row\\n        if(offset_neigh.x + 0.2 > num_neighs_per_row) {\\n          //in that case reset the column and increase the row\\n          offset_neigh.x = 0.1;\\n          offset_neigh.y += 1.0;\\n        }\\n      }\\n\\n      //The output is the sum of the attractive forces\\n      gl_FragColor = vec4(sum_pos,0,0,0);\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeAttractiveForcesComputationProgram(gpgpu, program, embeddingTex, offsetTex, neighIdTex, neighProbTex, numPoints, neighsPerRow, pntsPerRow, numRows, eta, targetTex) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow * 2);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var embeddingLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'embedding_tex');\r\n    gpgpu.setInputMatrixTexture(embeddingTex, embeddingLocation, 3);\r\n    var offsetLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'offset_tex');\r\n    gpgpu.setInputMatrixTexture(offsetTex, offsetLocation, 2);\r\n    var neighIdLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'neigh_id_tex');\r\n    gpgpu.setInputMatrixTexture(neighIdTex, neighIdLocation, 1);\r\n    var neighProbLocation = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'neigh_prob_tex');\r\n    gpgpu.setInputMatrixTexture(neighProbTex, neighProbLocation, 0);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var etaLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'eta');\r\n    gl.uniform1f(etaLoc, eta);\r\n    var neighsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_neighs_per_row');\r\n    gl.uniform1f(neighsPerRowLoc, neighsPerRow);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    gpgpu.executeProgram();\r\n}\r\nexport function createEmbeddingInitializationProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n\\n    uniform sampler2D random_tex;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n\\n    void main() {\\n      //add for nearest pixel interpolation\\n      vec2 half_pxl = vec2(0.5,0.5);\\n\\n      // Dimension of the fragment\\n      // 0 -> x :1 -> y\\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\\n      vec2 pnt_location = gl_FragCoord.xy - half_pxl;\\n      pnt_location.x = floor(pnt_location.x / 2.);\\n\\n      //just an extra fragment -> return\\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,1);\\n        return;\\n      }\\n\\n      float width = (points_per_row * 2.0);\\n      float row_coord = (pnt_location.y + 0.5)/num_rows;\\n      vec2 rad_coord = vec2((pnt_location.x * 2. + 0.5) / width, row_coord);\\n      vec2 ang_coord = vec2((pnt_location.x * 2. + 1.5) / width, row_coord);\\n\\n      float rad = texture2D(random_tex,rad_coord).r * 3.;\\n      float ang = texture2D(random_tex,ang_coord).r * 3.1415 * 2.;\\n\\n      gl_FragColor = vec4(rad,ang,0,1);\\n\\n      if(dimension < 0.5) {\\n        gl_FragColor = vec4(cos(ang) * rad,0,0,0);\\n      }else{\\n        gl_FragColor = vec4(sin(ang) * rad,0,0,0);\\n      }\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeEmbeddingInitializationProgram(gpgpu, program, randomTex, numPoints, pntsPerRow, numRows, targetTex) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow * 2);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var randomLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'random_tex');\r\n    gpgpu.setInputMatrixTexture(randomTex, randomLoc, 3);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    gpgpu.executeProgram();\r\n}\r\nexport function createDistributionParametersComputationProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n\\n    #define MAX_NEIGHBORS 128\\n    #define MAX_ITERATIONS 500\\n    #define FLOAT_MAX 10e30\\n    #define TOLERANCE 1e-5\\n\\n    uniform sampler2D knn_graph_tex;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n    uniform float num_neighs;\\n    uniform float perplexity;\\n\\n    vec2 half_pixel = vec2(0.5,0.5);\\n    float distances_squared[MAX_NEIGHBORS];\\n\\n    void readDistances(vec2 point_location) {\\n      for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\\n        if(float(n) >= num_neighs-0.1) {\\n          break;\\n        }\\n        vec2 knn_coordinates = vec2(\\n            (point_location.x * num_neighs + float(n) + half_pixel.x)\\n                                        /(points_per_row * num_neighs),\\n            (point_location.y + half_pixel.y) / num_rows\\n        );\\n        distances_squared[n] = texture2D(knn_graph_tex,knn_coordinates).g;\\n      }\\n    }\\n\\n    void main() {\\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\\n      //invalid points\\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,0);\\n        return;\\n      }\\n      readDistances(point_location);\\n\\n      //Beta computation\\n      float beta = 1.;\\n      float max_beta = FLOAT_MAX;\\n      float min_beta = -FLOAT_MAX;\\n      //To avoid computing the log at every iteration\\n      float log_perplexity = log(perplexity);\\n      float entropy_diff = 0.;\\n      float entropy = 0.;\\n      float sum_probabilities = 0.;\\n\\n      //Binary search for a maximum of MAX_ITERATIONS\\n      for(int iteration = 0; iteration < MAX_ITERATIONS; ++iteration) {\\n        //At every iteration I compute the\\n        //entropy enforced by the current beta\\n        sum_probabilities = 0.;\\n        entropy = 0.;\\n        for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\\n          if(float(n) >= num_neighs-0.1) {\\n            break;\\n          }\\n          float neigh_probability = exp(-beta * distances_squared[n]);\\n          sum_probabilities += neigh_probability;\\n          entropy += beta * distances_squared[n] * neigh_probability;\\n        }\\n\\n        entropy = entropy / sum_probabilities + log(sum_probabilities);\\n        entropy_diff = entropy - log_perplexity;\\n\\n        //the current beta is good enough!\\n        if(entropy_diff < TOLERANCE && -entropy_diff < TOLERANCE) {\\n          break;\\n        }\\n\\n        if(entropy_diff > 0.) {\\n          min_beta = beta;\\n          if(max_beta == FLOAT_MAX || max_beta == -FLOAT_MAX) {\\n            beta *= 2.;\\n          }else{\\n            beta = (beta + max_beta) / 2.;\\n          }\\n        }else{\\n          max_beta = beta;\\n          if(min_beta == -FLOAT_MAX || min_beta == FLOAT_MAX) {\\n            beta /= 2.;\\n          }else{\\n            beta = (beta + min_beta) / 2.;\\n          }\\n        }\\n      }\\n      gl_FragColor = vec4(beta,sum_probabilities,0,1);\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeDistributionParametersComputationProgram(gpgpu, program, knnGraph, numPoints, numNeighs, pntsPerRow, numRows, perplexity, targetTex) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var knnGraphLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'knn_graph_tex');\r\n    gpgpu.setInputMatrixTexture(knnGraph, knnGraphLoc, 0);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    var numNeighsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_neighs');\r\n    gl.uniform1f(numNeighsLoc, numNeighs);\r\n    var perplexityLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'perplexity');\r\n    gl.uniform1f(perplexityLoc, perplexity);\r\n    gpgpu.executeProgram();\r\n}\r\nexport function createGaussiaDistributionsFromDistancesProgram(gpgpu) {\r\n    var fragmentShaderSource = \"\\n    precision highp float;\\n    uniform sampler2D knn_graph_tex;\\n    uniform sampler2D parameters_tex;\\n    uniform float points_per_row;\\n    uniform float num_rows;\\n    uniform float num_points;\\n    uniform float num_neighs;\\n\\n    vec2 half_pixel = vec2(0.5,0.5);\\n\\n    void main() {\\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\\n      point_location.x = floor(point_location.x / num_neighs);\\n\\n      //invalid points\\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\\n        gl_FragColor = vec4(0,0,0,0);\\n        return;\\n      }\\n      float distance_squared\\n            = texture2D(knn_graph_tex,\\n                        gl_FragCoord.xy /\\n                        vec2(points_per_row*num_neighs,num_rows)\\n                      ).g;\\n      vec2 parameters\\n            = texture2D(parameters_tex,\\n                        (point_location.xy + half_pixel)/\\n                        vec2(points_per_row,num_rows)\\n                      ).rg;\\n      float beta = parameters.r;\\n      float normalization = parameters.g;\\n\\n      float probability = exp(-beta * distance_squared) / normalization;\\n      //check for NaN for degenerated knn (d = 0 for every point)\\n      if (!(probability < 0.0 || 0.0 < probability || probability == 0.0)) {\\n        probability = 0.;\\n      }\\n\\n      gl_FragColor = vec4(probability,0,0,1);\\n    }\\n  \";\r\n    return gpgpu.createProgram(fragmentShaderSource);\r\n}\r\nexport function executeGaussiaDistributionsFromDistancesProgram(gpgpu, program, knnGraph, parameters, numPoints, numNeighs, pntsPerRow, numRows, targetTex) {\r\n    var gl = gpgpu.gl;\r\n    if (targetTex != null) {\r\n        gpgpu.setOutputMatrixTexture(targetTex, numRows, pntsPerRow * numNeighs);\r\n    }\r\n    else {\r\n        tf.webgl.webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\r\n    }\r\n    gpgpu.setProgram(program);\r\n    var knnGraphLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'knn_graph_tex');\r\n    gpgpu.setInputMatrixTexture(knnGraph, knnGraphLoc, 0);\r\n    var parametersLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'parameters_tex');\r\n    gpgpu.setInputMatrixTexture(parameters, parametersLoc, 1);\r\n    var numRowsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_rows');\r\n    gl.uniform1f(numRowsLoc, numRows);\r\n    var numPointsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_points');\r\n    gl.uniform1f(numPointsLoc, numPoints);\r\n    var pntsPerRowLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'points_per_row');\r\n    gl.uniform1f(pntsPerRowLoc, pntsPerRow);\r\n    var numNeighsLoc = tf.webgl.webgl_util.getProgramUniformLocationOrThrow(gl, program, 'num_neighs');\r\n    gl.uniform1f(numNeighsLoc, numNeighs);\r\n    gpgpu.executeProgram();\r\n}\r\n//# sourceMappingURL=tsne_optimizer_util.js.map","map":"{\"version\":3,\"file\":\"tsne_optimizer_util.js\",\"sourceRoot\":\"\",\"sources\":[\"src/tsne_optimizer_util.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/tsne/tfjs-tsne/tsne_optimizer_util.d.ts","text":"import * as tf from '@tensorflow/tfjs-core';\r\nexport declare function createEmbeddingSplatterProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeEmbeddingSplatterProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, targetTex: WebGLTexture, embeddingTex: WebGLTexture, kernelTex: WebGLTexture, targetTexDiameter: number, numPoints: number, minX: number, minY: number, maxX: number, maxY: number, kernelSupport: number, pntsPerRow: number, numRows: number, vertexIdBuffer: WebGLBuffer): void;\r\nexport declare function createQInterpolatorProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeQInterpolatorProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, splatTex: WebGLTexture, embeddingTex: WebGLTexture, numPoints: number, minX: number, minY: number, maxX: number, maxY: number, pntsPerRow: number, numRows: number, targetTex?: WebGLTexture): void;\r\nexport declare function createXYInterpolatorProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeXYInterpolatorProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, splatTex: WebGLTexture, embeddingTex: WebGLTexture, targetTex: WebGLTexture, numPoints: number, minX: number, minY: number, maxX: number, maxY: number, pntsPerRow: number, numRows: number, eta: number): void;\r\nexport declare function createAttractiveForcesComputationProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeAttractiveForcesComputationProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, embeddingTex: WebGLTexture, offsetTex: WebGLTexture, neighIdTex: WebGLTexture, neighProbTex: WebGLTexture, numPoints: number, neighsPerRow: number, pntsPerRow: number, numRows: number, eta: number, targetTex?: WebGLTexture): void;\r\nexport declare function createEmbeddingInitializationProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeEmbeddingInitializationProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, randomTex: WebGLTexture, numPoints: number, pntsPerRow: number, numRows: number, targetTex?: WebGLTexture): void;\r\nexport declare function createDistributionParametersComputationProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeDistributionParametersComputationProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, knnGraph: WebGLTexture, numPoints: number, numNeighs: number, pntsPerRow: number, numRows: number, perplexity: number, targetTex?: WebGLTexture): void;\r\nexport declare function createGaussiaDistributionsFromDistancesProgram(gpgpu: tf.webgl.GPGPUContext): WebGLProgram;\r\nexport declare function executeGaussiaDistributionsFromDistancesProgram(gpgpu: tf.webgl.GPGPUContext, program: WebGLProgram, knnGraph: WebGLTexture, parameters: WebGLTexture, numPoints: number, numNeighs: number, pntsPerRow: number, numRows: number, targetTex?: WebGLTexture): void;\r\n"}}
